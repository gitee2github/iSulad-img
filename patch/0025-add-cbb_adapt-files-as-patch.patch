From 32579f4ae43186e4e5d17c20344bb8d7fb83ac72 Mon Sep 17 00:00:00 2001
From: LiFeng <lifeng68@huawei.com>
Date: Sun, 7 Jul 2019 22:41:58 -0400
Subject: [PATCH 25/37] add cbb_adapt files as patch

Signed-off-by: LiFeng <lifeng68@huawei.com>
---
 vendor/pkg/gopkgs/cbb_adapt/README.md         |   82 ++
 .../gopkgs/cbb_adapt/doc/crypto_cbb_desion.md |  243 ++++
 .../cbb_adapt/src/go/aeswithkey/aeswithkey.go | 1022 +++++++++++++++++
 .../cbb_adapt/src/go/gcrypto/gcrypto.go       |   55 +
 .../gopkgs/cbb_adapt/src/go/pbkdf2/pbkdf2.go  |   57 +
 5 files changed, 1459 insertions(+)
 create mode 100644 vendor/pkg/gopkgs/cbb_adapt/README.md
 create mode 100644 vendor/pkg/gopkgs/cbb_adapt/doc/crypto_cbb_desion.md
 create mode 100644 vendor/pkg/gopkgs/cbb_adapt/src/go/aeswithkey/aeswithkey.go
 create mode 100644 vendor/pkg/gopkgs/cbb_adapt/src/go/gcrypto/gcrypto.go
 create mode 100644 vendor/pkg/gopkgs/cbb_adapt/src/go/pbkdf2/pbkdf2.go

diff --git a/vendor/pkg/gopkgs/cbb_adapt/README.md b/vendor/pkg/gopkgs/cbb_adapt/README.md
new file mode 100644
index 0000000..8abc50a
--- /dev/null
+++ b/vendor/pkg/gopkgs/cbb_adapt/README.md
@@ -0,0 +1,82 @@
+Keymanagement With Self-design
+========
+
+## 介绍
+
+使用Golang编写的组件中，依赖公司的KMC会导致部署时依赖C库（glibc、openssl），会增加部署的复杂度与环境依赖。
+
+为了保持Golang工程的单纯性，使用Golang重写了一套密钥管理库，参考CloudSOP osscrypto 加密库的方案编写，与其完全兼容。（与公司KMC库不兼容。）
+
+## 使用方式
+
+### 示例代码
+
+```go
+package main
+
+import (
+    "fmt"
+
+    _ "pkg/gopkgs/cbb_adapt/src/go/aeswithkey"
+    "pkg/gopkgs/cbb_adapt/src/go/gcrypto"
+)
+
+func main() {
+
+    var plain = []byte("plaintext")
+
+    crypto, err := gcrypto.New("aeswithkey")
+    if err != nil {
+        fmt.Println(err)
+        return
+    }
+
+    encdata, err := crypto.Encrypt(0, string(plain[:]))
+    if err != nil {
+        fmt.Println(err)
+        return
+    }
+
+    decdata, err := crypto.Decrypt(0, encdata)
+    if err != nil {
+        fmt.Println(err)
+        return
+    }
+
+    fmt.Println("decdata = ", decdata)
+}
+```
+
+要点说明：
+
+1. gcrypto.New("aeswithkey") 只需要在初始化时调用一次.
+2. gcrypto.New中不会自动创建root.key与common_shared.key， 如果环境中没有这两个文件，需要在New之前调用 aeswithkey.CreateKeyFile("").   
+3. aeswithkey.CreateKeyfile(path string)， 如果入参为空，则从PAAS_CRYPTO_PATH环境变量读取路径，如果仍然为空，则在程序本地目录生成(./).
+4. Encrypt/Decrypt 中的第一个参数当前未使用
+5. 加解密库中不记录日志，所有错误都会通过error返回，请调用者自行记录日志
+
+
+
+## 配置
+
+### 配置密钥材料路径
+
+加解密库默认的密钥材料路径为程序本地目录 ./ ，用户可以通过设置环境变量 PAAS_CRYPTO_PATH来改变目录。
+
+    export PAAS_CRYPTO_PATH=/home/xxx
+
+如果设置的目录不可访问，加解密库会初始化失败。
+
+
+
+### 密钥材料
+
+加解密库使用root.key 与common_shared.key文件。root.key为根密钥材料的一部分，common_shared.key为使用root key加密的工作密钥，最终加密使用的工作密钥，是通过common_shared.key 与PBKDF2HmacSHA256 算法导出的工作的密钥。
+
+### 密钥缓存
+
+用户调用EncryptWithKey与DecryptWithKey时，会传入密钥材料。在多租户场景下，每次传入的密钥材料可能都不一样。 由于使用PBKDF算法导出密钥时，性能消耗很大。所以cbb_adapt默认对导出的密钥进行缓存，缓存数量默认为500个。 用户可以通过设置PAAS_CRYPTO_CACHE_SIZE环境变量来改变缓存大小。配置范围是0~1000000， 若配置超出范围，则会默认设置为500，并没有错误信息通知。
+
+	export PAAS_CRYPTO_CACHE_SIZE=100
+
+
diff --git a/vendor/pkg/gopkgs/cbb_adapt/doc/crypto_cbb_desion.md b/vendor/pkg/gopkgs/cbb_adapt/doc/crypto_cbb_desion.md
new file mode 100644
index 0000000..c7349cd
--- /dev/null
+++ b/vendor/pkg/gopkgs/cbb_adapt/doc/crypto_cbb_desion.md
@@ -0,0 +1,243 @@
+# 加解密CBB方案详细设计
+
+## 一、特性列表
+
+1. 支持使用预置的工作密钥对任意数据进行加解密
+2. 支持使用指定的工作密钥对任意数据进行加解密
+3. 支持创建根密钥/工作密钥
+4. 支持用指定的根密钥对工作密钥进行加解密
+5. 支持动态的更新根密钥与工作密钥
+6. 支持通过环境变量指定预置工作密钥路径
+
+
+
+*注：上述的“密钥”，指的是密钥材料，实际使用时会通过PBKDF2算法导出真正的密钥。*
+
+
+
+## 二、接口列表
+
+* 创建加解密引擎
+
+  func New(algo string) (engine Engine, err error)   // algo 默认为 "aeswithkey"
+
+  ​
+
+* 支持使用预置的工作密钥对任意数据进行加解密
+
+  func (eng Engine) Encrypt(domainId int, data string) (string, error)
+
+  func (eng Engine) Decrypt(domainId int, data string) (string, error)
+
+  ​
+
+* 支持使用指定的工作密钥对任意数据进行加解密
+
+  func (eng Engine) EncryptWithKey(key string, data string) (string, error)
+
+  func (eng Engine) DecryptWithKey(key string, data string) (string, error)
+
+  ​
+
+* 支持创建根密钥/工作密钥
+
+  func CreateKeyFile(path string) error
+
+  func CreateMaterial(input ...uint32) (string, error)
+
+  入参可选，包含以下三个参数：
+
+  para 1: ID
+
+  para 2: KdfType, only support PBKDF2-HMAC-SHA1(1) and PBKDF2-HMAC-SHA256(2)
+
+  para 3: Iteration, don't larger than 20480, default 2048
+
+  func AppendMaterial(oldMaterial string) (string, error)
+
+  备注：CreateMaterial 与 AppendMaterial 创建的Material未加密，如果是用于common_shared.key，需要用root.key加密。
+
+  ​
+
+* 支持用指定的根密钥对工作密钥进行加解密
+
+  func EncryptMaterial(key string, data string) (string, error)
+
+  func DecryptMaterial(key string, data string) (string, error)
+
+  ​
+
+* 支持通过环境变量指定预置工作密钥路径
+
+  export PAAS_CRYPTO_PATH=/xxx
+
+  ​
+
+
+
+## 三、设计描述
+
+### 3.1 密钥管理
+
+​	加解密CBB中提供了基本的本地密钥管理能力，遵从《密钥管理安全规范》。本地的密钥管理，主要是围绕着root.key与common_shared.key两个文件来进行， 两个key文件与加解密密钥的关系如下图：
+
+![本地密钥管理示意图](./pic/keymanage.png)
+
+
+
+设计说明：
+
+1. root.key 与common_shared.key中各保存有最多16个密钥材料，由Key ID标识，最大的Key ID为当前工作的密钥材料。密钥物料是按照Key ID递减顺序放置，即文件最开始的1024字节的密钥材料是最新的。
+
+2. CBB中的root key 由 root.key与代码中硬编码的密钥材料共同生成。
+
+3. common_shared.key中的密钥材料由root key 加密（每个密钥材料单独加密）。
+
+4. CBB运行时，内存中维护root key 与work key两条链。
+
+   ​
+
+   ​
+
+### 3.2 加解密
+
+![加密流程图](./pic/cipherprocess.png)
+
+设计说明：
+
+1. 使用当前Key ID最大的work key为明文加密。
+2. 使用16 Bytes 的安全随机IV。
+3. 使用AES256算法进行加密。
+4. 密文中包含加密的Key ID与IV。
+
+
+
+解密过程是上述过程的逆过程，不再重复说明。
+
+
+
+### 3.3 密钥更新
+
+设计说明：
+
+1. 在每次调用加解密功能时，都会判断本地root.key与common_shared.key是否有更新，若有更新，则重新读取root.key与common_shared.key，构建内部key chain。
+
+2. 若构建key chain过程中出现任何失败，都静默处理，继续用老的key chain进行后续的加解密动作。
+
+   ​
+
+
+
+## 四、数据结构
+
+### 4.1 密钥材料结构
+
+root.key与common_shared.key中的密钥材料结构一样，一个文件中最多包含16个密钥材料
+
+```go
+type MaterialItem struct {
+		Version     uint8           // 密钥材料版本，当前固定为1
+		Timestamp   [3]byte   		// 生成密钥材料的时间戳，以小时为单位
+		Id          uint32    		// 密钥材料ID，也是Key ID
+		KdfType     uint32    		// PBKDF算法类型，默认PBKDF2-HMAC-SHA256(2)
+		Iteration   uint32    		// PBKDF的迭代次数，默认2048
+		KeyLen      uint32    		// AES密钥长度，默认256
+		Salt        [32]byte  		// 盐值，安全随机数
+		MaterialLen uint32    		// 密钥材料长度
+		IsEncrypt   uint8     		// 密钥材料是否加密
+		Name        [23]byte  		// 加密该密钥材料的密钥名，默认为None或者root，没有实际用途
+		Reversed1   [48]byte  
+		Material    [864]byte 		// 密钥材料（未加密时为512 Bytes，后面都是随机填充
+		Checksum    [32]byte  		// 本密钥材料的SHA256 HASH值
+}                         
+```
+
+
+
+### 4.2 密文结构
+
+| 算法版本     | 物料序列号       | 初始向量 | 加密结果    |
+| -------- | ----------- | ---- | ------- |
+| 4字节，固定为1 | 4字节， Key ID | 16字节 | 16字节整数倍 |
+
+
+
+设计说明：
+
+1. 上述结构中的字节数，是指的binary形态的，实际输出会转换为ASCII文本，长度翻倍。例如 0xabc 会实际输出为"abc"。
+2. 加密方式为AES-CBC， 使用PKCS #5 padding方式，所以加密结果为16字节整数倍
+
+
+
+
+### 4.3 内部密钥链结构
+
+![密钥链示意图](./pic/keychain.png)
+
+设计说明：
+
+1. 每一个Engine 实例中维护一条root key chain与一条shared key chain， 不同engine可以有不同的key chain。
+
+2. Engine中维护有读取key file的timestamp， 用于判断是否需要进行密钥更新。
+
+3. 为了性能考虑，每次构建key chain时，就已经生成key保存在 KeyChainItem中，不需要每次加解密再用PBKDF算法导出key。  经过测试， 初始生成key比每次加解密导出key的性能高35倍以上。
+
+   ​
+
+
+
+## 五、设计约束
+
+1. 当前不提供接口设置加密算法。 可以通过手工修改root.key和common_shared.key中的KeyLen字段，在AES 128\AES192\AES256之间切换。
+
+2. 当前不考虑key ID回绕的情况， 需要提供root.key与common_shared.key的服务统一考虑。 可以采用在发生回绕时，一次更新完16个密钥材料的方式处理。（需要提前让各组件重新加密密文。）
+
+   ​
+
+## 六、异常情况处理
+
+### 1. key文件异常情况
+
+| 可变条件                   | 正常范围                      | 异常处理                                     |
+| ---------------------- | ------------------------- | ---------------------------------------- |
+| root.key 是否存在          | 存在                        | 创建root.key                               |
+| common_shared.key是否存在  | 存在                        | 创建common_shared.key                      |
+| root.key 是否加密          | 否                         | 返错                                       |
+| common_shared.key是否加密  | 是，并且是当前路径root.key中的材料所加密。 | 1. 如果common_shared.key加密，但root.key不存在或不是当前root.key所加密： 返错。  2. 如果common_shared.key中，存在有没加密的材料： 加密后刷新文件（密钥更新时，仅读取材料，不会重新加密） |
+| root.key 文件长度          | 1024整数倍，小于1024 * 16       | 返错                                       |
+| common_shared.key 文件长度 | 1024整数倍，小于1024 * 16       | 返错                                       |
+| version                | 1                         | 返错                                       |
+| Id                     | 正整数，且无重复                  | 1. 若存在重复，则以最靠前的最大Id为最新的材料。  （存在Id回绕？恶意修改为超大Id?）  2. 若为0：返错 |
+| KdfType                | [1:2]                     | 返错                                       |
+| Iteration              | [2048: 10*2048]           | 返错                                       |
+| KeyLen                 | （128, 192, 256）           | 返错                                       |
+| Salt                   | 32 Bytes随机值               | 不涉及                                      |
+| MaterialLen            | （512， 552）                | 返错                                       |
+| IsEncrypt              | （0, 1）                    | 同key文件是否加密部分                             |
+| Name                   | None, root                | 暂未判断                                     |
+| Material               | 随机值                       | 不涉及                                      |
+| Checksum               | 整个key结构的sha256校验          | 返错                                       |
+|                        |                           |                                          |
+|                        |                           |                                          |
+|                        |                           |                                          |
+|                        |                           |                                          |
+
+*备注：上述异常处理指在初始化过程中发生的异常。  在密钥更新过程中发生的key文件异常，都作忽略处理，更新过程终止。*
+
+### 2. 加解密数据异常情况
+
+| 可变条件    | 正常范围                               | 异常处理                                    |
+| ------- | ---------------------------------- | --------------------------------------- |
+| 明文长度    | 正整数                                | 返错                                      |
+| 密文长度    | 1. 最小80 Bytes；  2. 减掉48后，应该是32的整数倍 | 返错                                      |
+| version | 1                                  | 返错                                      |
+| KeyId   | 正整数，并且存在于common_shared.key文件中      | 返错                                      |
+| IV      | 16 Bytes 随机值                       | 不涉及                                     |
+| 密文加密密钥  | 密文是当前common_shared.key加密           | 返错，（若解密出的异常明文中，padding数据碰巧是对的，这种情况无法判断） |
+|         |                                    |                                         |
+|         |                                    |                                         |
+|         |                                    |                                         |
+
+
+
+
diff --git a/vendor/pkg/gopkgs/cbb_adapt/src/go/aeswithkey/aeswithkey.go b/vendor/pkg/gopkgs/cbb_adapt/src/go/aeswithkey/aeswithkey.go
new file mode 100644
index 0000000..1db2511
--- /dev/null
+++ b/vendor/pkg/gopkgs/cbb_adapt/src/go/aeswithkey/aeswithkey.go
@@ -0,0 +1,1022 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// iSulad-kit licensed under the Mulan PSL v1.
+// You can use this software according to the terms and conditions of the Mulan PSL v1.
+// You may obtain a copy of Mulan PSL v1 at:
+//     http://license.coscl.org.cn/MulanPSL
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+// PURPOSE.
+// See the Mulan PSL v1 for more details.
+// Description: iSulad image kit
+// Author: lifeng
+// Create: 2019-05-06
+
+package aeswithkey
+
+import (
+	"bytes"
+	"crypto/aes"
+	"crypto/cipher"
+	"crypto/rand"
+	"crypto/sha1"
+	"crypto/sha256"
+	"encoding/binary"
+	"encoding/hex"
+	"fmt"
+	"io/ioutil"
+	"math"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	"pkg/gopkgs/cbb_adapt/src/go/gcrypto"
+	"pkg/gopkgs/cbb_adapt/src/go/pbkdf2"
+)
+
+type Engine struct {
+	name            string
+	rootPath        string
+	rootTimestamp   time.Time
+	rootChain       *KeyChain
+	sharedPath      string
+	sharedTimestamp time.Time
+	sharedChain     *KeyChain
+	userInputCache  map[string]*KeyChain
+	cacheMutex      *sync.RWMutex
+}
+
+type KeyChainItem struct {
+	key      []byte
+	material *MaterialItem
+}
+
+type KeyChain []KeyChainItem
+
+type MaterialItem struct {
+	Version     uint8 // 1 bytes verion and 3 bytes reversed
+	Timestamp   [3]byte
+	Id          uint32
+	KdfType     uint32
+	Iteration   uint32
+	KeyLen      uint32
+	Salt        [32]byte
+	MaterialLen uint32
+	IsEncrypt   uint8
+	Name        [23]byte
+	LocalRandId [16]byte // The unique ID of the material
+	EncRandId   [16]byte // The unique ID of the root material which encrypt this material
+	Reversed1   [16]byte
+	Material    [864]byte // keep MaterialItem len is 1024 bytes
+	Checksum    [32]byte
+}
+
+type CipherHeader struct {
+	Version uint32
+	KeyId   uint32
+	Iv      [16]byte
+}
+
+const (
+	AES128_KEYLEN      = 16
+	AES192_KEYLEN      = 24
+	AES256_KEYLEN      = 32
+	UUID_LEN           = 36
+	PADDING_BLOCK      = 16
+	CIPHER_HEADER_LEN  = 24
+	MATERIAL_LEN       = 512
+	KEY_MATERIAL_LEN   = 1024
+	MAX_MATERIAL_ITEM  = 16
+	AES128_CBC         = 1
+	AES256_CBC         = 2
+	PBKDF2_HMAC_SHA1   = 1
+	PBKDF2_HMAC_SHA256 = 2
+	ROOTMATERIAL       = "root.key"
+	SHAREDMATERIAL     = "common_shared.key"
+	PBKDF2_ITERATION   = 2048
+	ENCRYPTED          = 1
+	UNENCRYPTED        = 0
+	MATERIAL_VERSION_1 = 1
+	MINIMAL_CIPHER_LEN = 80 //24 bytes header and 16 bytes cipherdata, and change to ascii, len multiple 2
+	MAXCACHESIZE       = 1000000
+	DEFAULTCACHESIZE   = 500
+)
+
+var localMaterial = []byte{198, 171, 80, 55, 230, 251, 110, 193, 71, 37, 104, 247, 211, 58, 32, 33, 6, 234, 23, 121, 79, 194, 160, 0, 125, 211, 188, 53, 116, 95, 108, 12, 20, 151, 154, 245, 194, 248, 121, 166, 80, 55, 35, 229, 165, 205, 29, 74, 168, 205, 141, 94, 3, 171, 184, 157, 191, 93, 44, 86, 58, 201, 48, 204, 223, 196, 179, 182, 107, 248, 254, 250, 115, 229, 172, 245, 217, 43, 222, 11, 3, 3, 161, 28, 98, 197, 160, 168, 167, 14, 104, 152, 99, 63, 12, 61, 68, 135, 122, 27, 188, 185, 113, 144, 222, 63, 205, 119, 109, 175, 1, 20, 153, 250, 228, 12, 25, 13, 25, 159, 205, 184, 185, 144, 227, 41, 244, 204, 95, 160, 73, 41, 42, 115, 98, 174, 144, 164, 19, 240, 184, 241, 187, 62, 196, 21, 116, 202, 245, 146, 254, 73, 236, 70, 56, 94, 35, 207, 50, 168, 180, 70, 135, 52, 198, 213, 98, 211, 113, 162, 159, 161, 160, 9, 168, 231, 230, 97, 123, 173, 208, 251, 234, 177, 87, 40, 18, 199, 170, 12, 149, 101, 118, 53, 159, 64, 243, 125, 229, 58, 171, 207, 233, 77, 156, 168, 228, 65, 164, 100, 247, 207, 128, 228, 192, 43, 221, 33, 153, 194, 31, 59, 115, 63, 2, 21, 102, 117, 190, 185, 141, 166, 37, 203, 131, 208, 167, 211, 1, 36, 102, 91, 131, 133, 114, 63, 164, 81, 115, 66, 214, 178, 81, 162, 165, 205, 54, 216, 62, 19, 225, 107, 34, 45, 110, 248, 181, 104, 58, 97, 65, 83, 223, 117, 176, 125, 153, 169, 219, 50, 31, 224, 247, 202, 76, 148, 38, 116, 41, 18, 115, 241, 146, 54, 90, 87, 28, 118, 166, 129, 197, 4, 223, 31, 68, 11, 140, 208, 64, 231, 231, 225, 224, 17, 164, 103, 17, 251, 61, 131, 151, 36, 15, 0, 65, 253, 97, 185, 114, 153, 175, 228, 39, 55, 119, 69, 88, 197, 160, 154, 195, 123, 151, 20, 216, 211, 114, 33, 199, 3, 199, 115, 176, 217, 108, 177, 114, 45, 251, 114, 206, 81, 105, 15, 51, 99, 219, 151, 27, 124, 236, 188, 7, 236, 110, 137, 193, 51, 189, 171, 109, 24, 79, 133, 135, 250, 221, 187, 62, 76, 21, 48, 147, 128, 247, 127, 150, 9, 214, 171, 110, 113, 50, 210, 29, 253, 239, 172, 82, 134, 229, 3, 67, 173, 226, 50, 100, 157, 164, 188, 197, 184, 39, 0, 202, 149, 173, 31, 86, 133, 9, 187, 233, 121, 191, 70, 192, 240, 31, 20, 123, 168, 0, 131, 18, 169, 64, 96, 189, 17, 137, 34, 237, 220, 37, 231, 105, 187, 226, 244, 184, 152, 204, 63, 187, 29, 139, 239, 122, 132, 204, 23, 184, 150, 119, 174, 154, 115, 185, 185, 151, 145, 214, 185, 248, 81, 4, 192, 166, 37, 66, 10, 76, 242, 248, 193, 72, 74, 242, 253, 142, 193, 12, 150, 238, 5, 237, 44, 163, 190, 223, 162}
+
+var cacheSize int
+
+func init() {
+	gcrypto.Register("aeswithkey", Initial)
+
+	sizeString := os.Getenv("PAAS_CRYPTO_CACHE_SIZE")
+	size, err := strconv.Atoi(sizeString)
+	if err != nil {
+		size = DEFAULTCACHESIZE
+	}
+
+	if size < 0 || size > MAXCACHESIZE {
+		size = DEFAULTCACHESIZE
+	}
+
+	cacheSize = size
+}
+
+func Initial() (gcrypto.Engine, error) {
+	var engine Engine
+
+	workpath := os.Getenv("PAAS_CRYPTO_PATH")
+	if workpath == "" {
+		workpath = "."
+	}
+
+	workpathabs, err := filepath.Abs(workpath)
+	if err != nil {
+		return nil, fmt.Errorf("Initial env workpath is not correct. %v", err)
+	}
+
+	rootfile := strings.Join([]string{workpathabs, ROOTMATERIAL}, "/")
+	sharedfile := strings.Join([]string{workpathabs, SHAREDMATERIAL}, "/")
+
+	engine.name = "aeswithkey"
+	engine.rootPath = rootfile
+	engine.sharedPath = sharedfile
+	engine.userInputCache = make(map[string]*KeyChain, int(math.Min(float64(cacheSize), float64(DEFAULTCACHESIZE))))
+	engine.cacheMutex = new(sync.RWMutex)
+
+	err = engine.resetEngine()
+	if err != nil {
+		return nil, fmt.Errorf("Initial %v", err)
+	}
+
+	return &engine, nil
+}
+
+func (eng *Engine) resetEngine() error {
+	rootinfo, err := ioutil.ReadFile(eng.rootPath)
+	if err != nil {
+		return fmt.Errorf("resetEngine read root material failed. %v", err)
+	}
+
+	rootfileInfo, err := os.Stat(eng.rootPath)
+	if err != nil {
+		return fmt.Errorf("resetEngine read root file info failed. %v", err)
+	}
+
+	rootchain, err := newKeyChain(rootinfo)
+	if err != nil {
+		return fmt.Errorf("resetEngine parse root material failed. %v", err)
+	}
+
+	err = rootchain.resetRootKey()
+	if err != nil {
+		return fmt.Errorf("resetEngine %v", err)
+	}
+
+	sharedinfo, err := ioutil.ReadFile(eng.sharedPath)
+	if err != nil {
+		return fmt.Errorf("resetEngine read shared material failed. %v", err)
+	}
+
+	sharedfileInfo, err := os.Stat(eng.sharedPath)
+	if err != nil {
+		return fmt.Errorf("resetEngine read shared file info failed. %v", err)
+	}
+
+	sharedchain, err := newKeyChain(sharedinfo)
+	if err != nil {
+		return fmt.Errorf("resetEngine parse shared material failed. %v", err)
+	}
+
+	err = sharedchain.resetKey(*rootchain)
+	if err != nil {
+		return fmt.Errorf("resetEngine %v", err)
+	}
+
+	eng.rootTimestamp = rootfileInfo.ModTime()
+	eng.rootChain = rootchain
+	eng.sharedTimestamp = sharedfileInfo.ModTime()
+	eng.sharedChain = sharedchain
+
+	return nil
+}
+
+func (eng Engine) isNeedUpdate() bool {
+	rootfileInfo, err := os.Stat(eng.rootPath)
+	if err != nil {
+		return false
+	}
+
+	sharedfileInfo, err := os.Stat(eng.sharedPath)
+	if err != nil {
+		return false
+	}
+
+	if eng.rootTimestamp.Before(rootfileInfo.ModTime()) {
+		return true
+	}
+
+	if eng.sharedTimestamp.Before(sharedfileInfo.ModTime()) {
+		return true
+	}
+
+	return false
+}
+
+func (eng Engine) Encrypt(domainId int, data string) (string, error) {
+	if eng.isNeedUpdate() {
+		err := (&eng).resetEngine()
+		if err != nil {
+			return "", err
+		}
+	}
+
+	item := eng.sharedChain.latestItem()
+	return encrypt(item.material.Id, item.key, data)
+}
+
+func (eng Engine) Decrypt(domainId int, data string) (string, error) {
+	if eng.isNeedUpdate() {
+		err := (&eng).resetEngine()
+		if err != nil {
+			return "", err
+		}
+	}
+
+	return decrypt(*eng.sharedChain, data)
+}
+
+func (Engine) FileEncrypt(domainId int, srcPath string, dstPath string) error {
+	return fmt.Errorf("Not Implemented")
+}
+
+func (Engine) FileDecrypt(domainId int, srcPath string, dstPath string) error {
+	return fmt.Errorf("Not Implemented")
+}
+
+func (eng Engine) EncryptWithKey(key string, data string) (string, error) {
+	var chain *KeyChain
+	var err error
+	var ok bool
+
+	if chain, ok = eng.cachedChain(key); !ok {
+		chain, err = newKeyChain([]byte(key))
+		if err != nil {
+			return "", fmt.Errorf("EncryptWithKey %v", err)
+		}
+
+		err = chain.resetKey(nil)
+		if err != nil {
+			return "", fmt.Errorf("EncryptWithKey %v", err)
+		}
+
+		eng.addCache(key, chain)
+	}
+
+	item := chain.latestItem()
+	return encrypt(item.material.Id, item.key, data)
+}
+
+func (eng Engine) DecryptWithKey(key string, data string) (string, error) {
+	var chain *KeyChain
+	var err error
+	var ok bool
+
+	if chain, ok = eng.cachedChain(key); !ok {
+		chain, err = newKeyChain([]byte(key))
+		if err != nil {
+			return "", fmt.Errorf("DecryptWithKey %v", err)
+		}
+
+		err = chain.resetKey(nil)
+		if err != nil {
+			return "", fmt.Errorf("DecryptWithKey %v", err)
+		}
+
+		eng.addCache(key, chain)
+	}
+
+	return decrypt(*chain, data)
+}
+
+func (eng Engine) cachedChain(key string) (*KeyChain, bool) {
+	if cacheSize == 0 {
+		return nil, false
+	}
+
+	eng.cacheMutex.RLock()
+	chain, ok := eng.userInputCache[cacheIndex(key)]
+	eng.cacheMutex.RUnlock()
+	return chain, ok
+}
+
+func (eng *Engine) addCache(key string, chain *KeyChain) {
+	if cacheSize == 0 {
+		return
+	}
+
+	eng.cacheMutex.Lock()
+	if len(eng.userInputCache) >= cacheSize {
+		for k, _ := range eng.userInputCache {
+			delete(eng.userInputCache, k)
+			break
+		}
+	}
+
+	eng.userInputCache[cacheIndex(key)] = chain
+	eng.cacheMutex.Unlock()
+}
+
+func cacheIndex(input string) string {
+	h := sha1.New()
+	sum := h.Sum([]byte(input))
+	return string(sum[:])
+}
+
+func newMaterial(info []byte) (*MaterialItem, error) {
+	var material MaterialItem
+
+	if info == nil {
+		return nil, fmt.Errorf("material input is nil.")
+	}
+
+	buf := bytes.NewReader(info)
+	err := binary.Read(buf, binary.BigEndian, &material)
+	if err != nil {
+		return nil, err
+	}
+
+	if material.Version != MATERIAL_VERSION_1 {
+		return nil, fmt.Errorf("material version %d is not supported.", material.Version)
+	}
+
+	if material.Id == 0 {
+		return nil, fmt.Errorf("material id %d is not supported.", material.Id)
+	}
+
+	if material.KdfType < 1 || material.KdfType > 2 {
+		return nil, fmt.Errorf("material kdf type %d is not supported.", material.KdfType)
+	}
+
+	if material.KeyLen != AES128_KEYLEN*8 && material.KeyLen != AES192_KEYLEN*8 && material.KeyLen != AES256_KEYLEN*8 {
+		return nil, fmt.Errorf("material keylen %d is not supported.", material.KeyLen)
+	}
+
+	//check materialLen , plain material len is 512, cipher material len is 512 + 16 padding + 24 cipher header
+	if material.MaterialLen != MATERIAL_LEN && material.MaterialLen != MATERIAL_LEN+PADDING_BLOCK+CIPHER_HEADER_LEN {
+		return nil, fmt.Errorf("material MaterialLen %d is not correct.", material.MaterialLen)
+	}
+
+	//check iteration, it is not constant, but could not too mush, to prevent DoS attacks
+	if material.Iteration > PBKDF2_ITERATION*10 {
+		return nil, fmt.Errorf("material iteration %d is too lager.", material.Iteration)
+	}
+
+	//check checksum
+	checksum := sha256.Sum256(info[:992])
+	if bytes.Compare(checksum[:], material.Checksum[:]) != 0 {
+		return nil, fmt.Errorf("material checksum error.")
+	}
+
+	//other member will not cause crash, and will be check in other func
+	return &material, nil
+}
+
+func (material MaterialItem) workKey() []byte {
+	var workkey []byte
+
+	plainbuf := []byte(fmt.Sprintf("%X", material.Material[:material.MaterialLen]))
+	switch material.KdfType {
+	case PBKDF2_HMAC_SHA1:
+		workkey = pbkdf2.Key(plainbuf, material.Salt[:], int(material.Iteration), int(material.KeyLen)/8, sha1.New)
+	case PBKDF2_HMAC_SHA256:
+		workkey = pbkdf2.Key(plainbuf, material.Salt[:], int(material.Iteration), int(material.KeyLen)/8, sha256.New)
+	}
+
+	return workkey
+}
+
+func (material MaterialItem) rootKey() []byte {
+	var i uint32
+	for i = 0; i < material.MaterialLen; i++ {
+		material.Material[i] = material.Material[i] ^ (0xff & localMaterial[i])
+	}
+
+	return material.workKey()
+}
+
+func (material *MaterialItem) decrypt(keyChain KeyChain) error {
+	if material.IsEncrypt == UNENCRYPTED {
+		return fmt.Errorf("material is already decrypted.")
+	}
+
+	plain, err := decrypt(keyChain, string(material.Material[:material.MaterialLen]))
+	if err != nil {
+		return fmt.Errorf("material %v", err)
+	}
+
+	material.MaterialLen = uint32(len(plain))
+	material.IsEncrypt = UNENCRYPTED
+	copy(material.Material[:], []byte(plain))
+	copy(material.EncRandId[:], material.LocalRandId[:])
+	copy(material.Name[:], []byte("root")) //TODO: change "root" to "None"
+
+	err = material.resetChecksum()
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func (material *MaterialItem) encrypt(keyChain KeyChain) error {
+	//If item is already encrypted, skip
+	if material.IsEncrypt == ENCRYPTED {
+		return nil
+	}
+
+	key := keyChain.latestItem()
+	encdata, err := encrypt(key.material.Id, key.key, string(material.Material[:material.MaterialLen]))
+	if err != nil {
+		return fmt.Errorf("material encrypt failed. %v", err)
+	}
+
+	//change ASCII string to bit string
+	data := string(make([]byte, len(encdata)/2))
+	_, err = fmt.Sscanf(encdata, "%x", &data)
+	if err != nil {
+		return fmt.Errorf("material encrypt change ascii to bits stream failed. %v", err)
+	}
+
+	material.MaterialLen = uint32(len(data))
+	material.IsEncrypt = ENCRYPTED
+	copy(material.Material[:], []byte(data))
+	copy(material.EncRandId[:], key.material.LocalRandId[:])
+	copy(material.Name[:], []byte("root"))
+
+	err = material.resetChecksum()
+	if err != nil {
+		return fmt.Errorf("material encrypt %v", err)
+	}
+
+	return nil
+}
+
+func (material *MaterialItem) resetChecksum() error {
+	buf := new(bytes.Buffer)
+	err := binary.Write(buf, binary.BigEndian, material)
+	if err != nil {
+		return fmt.Errorf("material reset checksum failed. %v", err)
+	}
+	forCheck := buf.Bytes()
+
+	checksum := sha256.Sum256(forCheck[:992])
+	copy(material.Checksum[:], checksum[:])
+
+	return nil
+}
+
+func (material MaterialItem) toString() (string, error) {
+	buf := new(bytes.Buffer)
+	err := binary.Write(buf, binary.BigEndian, material)
+	if err != nil {
+		return "", err
+	}
+
+	return buf.String(), nil
+}
+
+func newKeyChain(key []byte) (*KeyChain, error) {
+	var keychain KeyChain
+
+	if key == nil {
+		return nil, fmt.Errorf("newKeyChain input is nil.")
+	}
+
+	keyLen := len(key)
+	if keyLen == 0 || keyLen%KEY_MATERIAL_LEN != 0 {
+		return nil, fmt.Errorf("newKeyChain key len %d is not correct.", keyLen)
+	}
+
+	MaterialNum := keyLen / KEY_MATERIAL_LEN
+	if MaterialNum > MAX_MATERIAL_ITEM {
+		return nil, fmt.Errorf("newKeyChain key item %d is larger than max value.", MaterialNum)
+	}
+
+	for i := 0; i < MaterialNum; i++ {
+		material := key[i*KEY_MATERIAL_LEN : (i+1)*KEY_MATERIAL_LEN]
+
+		item, err := newKeyChainItem(material)
+		if err != nil {
+			return nil, fmt.Errorf("newKeyChain create item failed. %v", err)
+		}
+
+		keychain = append(keychain, *item)
+	}
+
+	return &keychain, nil
+}
+
+// id is 0 for the lastest key
+func (chain KeyChain) key(id uint32) ([]byte, error) {
+	for _, item := range chain {
+		if item.material != nil && item.material.Id == id {
+			if item.key == nil {
+				err := item.resetKey(nil)
+				if err != nil {
+					return nil, fmt.Errorf("KeyChain get key failed. %v", err)
+				}
+			}
+
+			return item.key, nil
+		}
+	}
+
+	return nil, fmt.Errorf("KeyChain the key %d is not exist.", id)
+}
+
+func (chain KeyChain) latestItem() *KeyChainItem {
+	max := 0
+	latest := uint32(0)
+
+	for i, item := range chain {
+		if item.material.Id > latest {
+			max = i
+			latest = item.material.Id
+		}
+	}
+
+	return &chain[max]
+}
+
+func (chain *KeyChain) decrypt(rootchain KeyChain) error {
+	for i := range *chain {
+		err := (&(*chain)[i]).material.decrypt(rootchain)
+		if err != nil {
+			return fmt.Errorf("KeyChain decrypt failed. %v", err)
+		}
+	}
+
+	return nil
+}
+
+func (chain *KeyChain) encrypt(rootchain KeyChain) error {
+	for i := range *chain {
+		err := (&(*chain)[i]).material.encrypt(rootchain)
+		if err != nil {
+			return fmt.Errorf("KeyChain encrypt failed. %v", err)
+		}
+	}
+
+	return nil
+}
+
+func (chain *KeyChain) resetRootKey() error {
+	for i := range *chain {
+		err := (&(*chain)[i]).resetRootKey()
+		if err != nil {
+			return fmt.Errorf("KeyChain reset root key failed. %v", err)
+		}
+	}
+
+	return nil
+}
+
+func (chain *KeyChain) resetKey(keychain KeyChain) error {
+	for i := range *chain {
+		err := (&(*chain)[i]).resetKey(keychain)
+		if err != nil {
+			return fmt.Errorf("KeyChain reset key failed. %v", err)
+		}
+	}
+
+	return nil
+}
+
+func (chain KeyChain) toString() (string, error) {
+	buf := new(bytes.Buffer)
+
+	for _, item := range chain {
+		material, err := (*(item.material)).toString()
+		if err != nil {
+			return "", fmt.Errorf("KeyChain to string failed. %v", err)
+		}
+
+		_, err = buf.WriteString(material)
+		if err != nil {
+			return "", fmt.Errorf("KeyChain write string failed. %v", err)
+		}
+	}
+
+	return buf.String(), nil
+}
+
+func newKeyChainItem(key []byte) (*KeyChainItem, error) {
+	var material *MaterialItem
+	var workkey []byte
+
+	if key == nil {
+		return nil, fmt.Errorf("newKeyChainItem input is nil.")
+	}
+
+	if len(key) != KEY_MATERIAL_LEN {
+		return nil, fmt.Errorf("newKeyChainItem key len %d is not %d.", len(key), KEY_MATERIAL_LEN)
+	}
+
+	material, err := newMaterial(key)
+	if err != nil {
+		return nil, fmt.Errorf("newKeyChainItem key format error. %v", err)
+	}
+
+	return &KeyChainItem{key: workkey, material: material}, nil
+}
+
+func (item *KeyChainItem) resetKey(keyChain KeyChain) error {
+	if item.material.IsEncrypt == ENCRYPTED {
+		if keyChain == nil {
+			return fmt.Errorf("KeyChainItem no key to decrypt material.")
+		}
+
+		err := item.material.decrypt(keyChain)
+		if err != nil {
+			return fmt.Errorf("KeyChainItem resetKey decrypt error. %v", err)
+		}
+	}
+
+	workkey := item.material.workKey()
+	keylen := len(workkey)
+	if keylen != AES128_KEYLEN && keylen != AES192_KEYLEN && keylen != AES256_KEYLEN {
+		return fmt.Errorf("KeyChainItem key len %d is not correct.", keylen)
+	}
+
+	item.key = workkey
+	return nil
+}
+
+func (item *KeyChainItem) resetRootKey() error {
+	if item.material.IsEncrypt == ENCRYPTED {
+		return fmt.Errorf("KeyChainItem root key material can't be encrypted.")
+	}
+
+	rootkey := item.material.rootKey()
+	keylen := len(rootkey)
+	if keylen != AES128_KEYLEN && keylen != AES192_KEYLEN && keylen != AES256_KEYLEN {
+		return fmt.Errorf("KeyChainItem key len %d is not correct.", keylen)
+	}
+
+	item.key = rootkey
+	return nil
+}
+
+func encrypt(id uint32, key []byte, data string) (string, error) {
+	var header CipherHeader
+
+	//if len(data) == 0 {
+	//	return "", fmt.Errorf("Encrypt data len is 0.")
+	//}
+
+	//TODO:Version is not used currently
+	header.Version = 1
+	header.KeyId = id
+
+	_, err := rand.Read(header.Iv[:])
+	if err != nil {
+		return "", fmt.Errorf("Encrypt create rand IV failed. %v", err)
+	}
+
+	text, err := encryptAES(key, data, header.Iv[:])
+	if err != nil {
+		return "", err
+	}
+
+	buf := new(bytes.Buffer)
+	err = binary.Write(buf, binary.BigEndian, header)
+	if err != nil {
+		return "", fmt.Errorf("Encrypt write cipher header failed. %v", err)
+	}
+	_, err = buf.Write(text)
+	if err != nil {
+		return "", fmt.Errorf("Encrypt write cipher data failed. %v", err)
+	}
+
+	return strings.ToUpper(hex.EncodeToString(buf.Bytes())), err //for compatible cloudsop cbb , but this cipher format is bullshit
+}
+
+func encryptAES(key []byte, data string, iv []byte) ([]byte, error) {
+	plainpad := padding(data)
+	text := make([]byte, len(plainpad))
+
+	cipherEngine, err := aes.NewCipher(key)
+	if err != nil {
+		return nil, fmt.Errorf("Encrypt create cipher failed. %v", err)
+	}
+
+	aesEngine := cipher.NewCBCEncrypter(cipherEngine, iv)
+	aesEngine.CryptBlocks(text, plainpad)
+
+	return text, nil
+}
+
+func decrypt(chain KeyChain, dataStr string) (string, error) {
+	var header CipherHeader
+	var data []byte
+	var err error
+
+	if uint32(len(dataStr)) < uint32(MINIMAL_CIPHER_LEN) {
+		return "", fmt.Errorf("Decrypt data len %d is less than minimal len %d.", len(dataStr), MINIMAL_CIPHER_LEN)
+	}
+
+	//For material decryption, input encdata is bits stream
+	//Buf for other data decryption, input encdata is ascii bytes, so we must change ascii bytes into bits stream
+	if []byte(dataStr)[0] >= '0' {
+		data, err = hex.DecodeString(dataStr)
+		if err != nil {
+			return "", fmt.Errorf("Decrypt change ascii to bits stream failed. %v", err)
+		}
+	} else {
+		data = []byte(dataStr)
+	}
+
+	buf := bytes.NewReader(data)
+	err = binary.Read(buf, binary.BigEndian, &header)
+	if err != nil {
+		return "", fmt.Errorf("Decrypt parse header failed. %v", err)
+	}
+
+	//Some old material maybe 2, so comment here
+	//if header.Version != 1 {
+	//	return "", fmt.Errorf("Decrypt cipher version %d is not support.", header.Version)
+	//}
+
+	workkey, err := chain.key(header.KeyId)
+	if err != nil {
+		return "", fmt.Errorf("Decrypt key error. %v", err)
+	}
+
+	ciptext := []byte(data)[CIPHER_HEADER_LEN:]
+
+	return decryptAES(workkey, ciptext, header.Iv[:])
+}
+
+func decryptAES(key, data, iv []byte) (string, error) {
+	if len(data)%aes.BlockSize != 0 {
+		return "", fmt.Errorf("Decrypt cipher data len %d is not correct, not a multiple of %d.", len(data), aes.BlockSize)
+	}
+
+	cipherEngine, err := aes.NewCipher(key)
+	if err != nil {
+		return "", fmt.Errorf("Decrypt create cipher failed. %v", err)
+	}
+
+	text := make([]byte, len(data))
+	aesEngine := cipher.NewCBCDecrypter(cipherEngine, iv)
+	aesEngine.CryptBlocks(text, data)
+
+	retstr, err := unpadding(text)
+	if err != nil {
+		return "", fmt.Errorf("Decrypt %v", err)
+	}
+
+	return retstr, nil
+}
+
+func padding(plaintext string) []byte {
+	//pkcs5 padding
+	plainlen := len(plaintext)
+	paddinglen := aes.BlockSize - plainlen%aes.BlockSize
+	plainpad := make([]byte, plainlen+paddinglen)
+	copy(plainpad, plaintext)
+	for i := 0; i < paddinglen; i++ {
+		plainpad[plainlen+i] = byte(paddinglen)
+	}
+
+	return plainpad
+}
+
+func unpadding(plaintext []byte) (string, error) {
+	//pkcs5 unpadding
+	plainlen := len(plaintext)
+	padnum := int(plaintext[plainlen-1])
+	if aes.BlockSize < padnum || padnum == 0 {
+		return "", fmt.Errorf("unpadding failed, pad number %d is not correct.", padnum)
+	}
+
+	// can't exclude the scenario that padnum == 1
+	if int(plaintext[plainlen-padnum]) != padnum {
+		return "", fmt.Errorf("unpadding failed, data abnormal, maybe encrypted by other key.")
+	}
+
+	return string(plaintext[:(plainlen - padnum)]), nil
+}
+
+/*
+ * para 1: ID
+ * para 2: KdfType, only support PBKDF2_HMAC_SHA1(1) and PBKDF2_HMAC_SHA256(2)
+ * para 3: Iteration, don't larger than 20480, default 2048
+ */
+func CreateMaterial(input ...uint32) (string, error) {
+	var material MaterialItem
+
+	num := len(input)
+	if num < 1 || num > 3 {
+		return "", fmt.Errorf("CreateMaterial input para number error.")
+	}
+
+	material.Version = MATERIAL_VERSION_1
+	material.Id = input[0]
+	if num >= 2 && input[1] <= PBKDF2_HMAC_SHA256 {
+		material.KdfType = input[1]
+	} else {
+		material.KdfType = PBKDF2_HMAC_SHA256
+	}
+	if num >= 3 {
+		material.Iteration = input[2]
+	} else {
+		material.Iteration = PBKDF2_ITERATION
+	}
+	material.KeyLen = AES256_KEYLEN * 8
+	material.MaterialLen = MATERIAL_LEN
+	material.IsEncrypt = 0
+	copy(material.Name[:], []byte("root")) //TODO: change "root" to "None"
+
+	var timestamp = make([]byte, 8)
+	binary.BigEndian.PutUint64(timestamp, uint64(time.Now().Unix()/3600))
+	copy(material.Timestamp[:], timestamp[5:8])
+
+	rand.Read(material.Salt[:])
+	rand.Read(material.LocalRandId[:])
+	rand.Read(material.EncRandId[:])
+	rand.Read(material.Reversed1[:])
+	rand.Read(material.Material[:])
+
+	err := (&material).resetChecksum()
+	if err != nil {
+		return "", fmt.Errorf("CreateMaterial %v", err)
+	}
+
+	return material.toString()
+}
+
+func AppendMaterial(oldMaterial string) (string, error) {
+	var oldMaterialStr string
+
+	oldMaterialByte := []byte(oldMaterial)
+	chain, err := newKeyChain(oldMaterialByte)
+	if err != nil {
+		return "", fmt.Errorf("AppendMaterial parse key chain failed. %v", err)
+	}
+
+	maxKey := chain.latestItem()
+
+	material, err := CreateMaterial(maxKey.material.Id + 1)
+	if err != nil {
+		return "", fmt.Errorf("AppendMaterial create new material failed. %v", err)
+	}
+
+	//if oldMaterial have more than 16 material , delete the second last one
+	if len(oldMaterialByte) == MAX_MATERIAL_ITEM*KEY_MATERIAL_LEN {
+		oldMaterialStr = strings.Join([]string{string(oldMaterialByte[0 : (MAX_MATERIAL_ITEM-2)*KEY_MATERIAL_LEN]), string(oldMaterialByte[(MAX_MATERIAL_ITEM-1)*KEY_MATERIAL_LEN:])}, "")
+	} else {
+		oldMaterialStr = string(oldMaterialByte)
+	}
+
+	return strings.Join([]string{material, oldMaterialStr}, ""), nil
+}
+
+func EncryptMaterial(key string, data string) (string, error) {
+
+	rootchain, err := newKeyChain([]byte(key))
+	if err != nil {
+		return "", fmt.Errorf("EncryptMaterial parse root key chain failed. %v", err)
+	}
+
+	err = rootchain.resetRootKey()
+	if err != nil {
+		return "", fmt.Errorf("EncryptMaterial %v", err)
+	}
+
+	sharedchain, err := newKeyChain([]byte(data))
+	if err != nil {
+		return "", fmt.Errorf("EncryptMaterial parse shared key chain failed. %v", err)
+	}
+
+	err = sharedchain.encrypt(*rootchain)
+	if err != nil {
+		return "", fmt.Errorf("EncryptMaterial %v", err)
+	}
+
+	retstr, err := sharedchain.toString()
+	if err != nil {
+		return "", fmt.Errorf("EncryptMaterial %v", err)
+	}
+
+	return retstr, nil
+}
+
+func DecryptMaterial(key string, data string) (string, error) {
+
+	rootchain, err := newKeyChain([]byte(key))
+	if err != nil {
+		return "", fmt.Errorf("DecryptMaterial parse root key chain failed. %v", err)
+	}
+
+	err = rootchain.resetRootKey()
+	if err != nil {
+		return "", fmt.Errorf("DecryptMaterial %v", err)
+	}
+
+	sharedchain, err := newKeyChain([]byte(data))
+	if err != nil {
+		return "", fmt.Errorf("DecryptMaterial parse shared key chain failed. %v", err)
+	}
+
+	err = sharedchain.decrypt(*rootchain)
+	if err != nil {
+		return "", fmt.Errorf("DecryptMaterial %v", err)
+	}
+
+	retstr, err := sharedchain.toString()
+	if err != nil {
+		return "", fmt.Errorf("DecryptMaterial %v", err)
+	}
+
+	return retstr, nil
+}
+
+func CreateKeyFile(path string) error {
+	var workpath string
+	var rootinfo string
+	var sharedinfo string
+	var isSharedNew = false
+
+	if path != "" {
+		workpath = path
+	} else {
+		workpath = os.Getenv("PAAS_CRYPTO_PATH")
+		if workpath == "" {
+			workpath = "."
+		}
+	}
+
+	workpathabs, err := filepath.Abs(workpath)
+	if err != nil {
+		return fmt.Errorf("CreateKeyFile file workpath is not correct. %v", err)
+	}
+
+	rootfile := strings.Join([]string{workpathabs, ROOTMATERIAL}, "/")
+	sharedfile := strings.Join([]string{workpathabs, SHAREDMATERIAL}, "/")
+
+	if _, err = os.Stat(rootfile); err != nil {
+		rootinfo, err = CreateMaterial(1)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile create root material failed. %v", err)
+		}
+
+		err = ioutil.WriteFile(rootfile, []byte(rootinfo), 0600)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile write root.key file failed. %v", err)
+		}
+	} else {
+		rootinfoByte, err := ioutil.ReadFile(rootfile)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile read root material failed. %v", err)
+		}
+		rootinfo = string(rootinfoByte)
+	}
+
+	if _, err = os.Stat(sharedfile); err != nil {
+		sharedinfo, err = CreateMaterial(1)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile create shared material failed. %v", err)
+		}
+
+		isSharedNew = true
+	} else {
+		sharedinfoByte, err := ioutil.ReadFile(sharedfile)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile read shared material failed. %v", err)
+		}
+		sharedinfo = string(sharedinfoByte)
+	}
+
+	//if common_shared.key is already encrypted, EncryptMaterial will not encrypt again
+	encShared, err := EncryptMaterial(rootinfo, sharedinfo)
+	if err != nil {
+		return fmt.Errorf("CreateKeyFile Encrypt shared material failed. %v", err)
+	}
+
+	if strings.Compare(sharedinfo, encShared) != 0 {
+		isSharedNew = true
+	}
+
+	if isSharedNew {
+		err = ioutil.WriteFile(sharedfile, []byte(encShared), 0600)
+		if err != nil {
+			return fmt.Errorf("CreateKeyFile write common_shared.key file failed. %v", err)
+		}
+	}
+
+	return nil
+}
diff --git a/vendor/pkg/gopkgs/cbb_adapt/src/go/gcrypto/gcrypto.go b/vendor/pkg/gopkgs/cbb_adapt/src/go/gcrypto/gcrypto.go
new file mode 100644
index 0000000..7a03e5f
--- /dev/null
+++ b/vendor/pkg/gopkgs/cbb_adapt/src/go/gcrypto/gcrypto.go
@@ -0,0 +1,55 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// iSulad-kit licensed under the Mulan PSL v1.
+// You can use this software according to the terms and conditions of the Mulan PSL v1.
+// You may obtain a copy of Mulan PSL v1 at:
+//     http://license.coscl.org.cn/MulanPSL
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+// PURPOSE.
+// See the Mulan PSL v1 for more details.
+// Description: iSulad image kit
+// Author: lifeng
+// Create: 2019-05-06
+
+package gcrypto
+
+import (
+	"fmt"
+)
+
+type Engine interface {
+	Encrypt(domainId int, data string) (string, error)
+	Decrypt(domainId int, encData string) (string, error)
+	FileEncrypt(domainId int, srcPath string, dstPath string) error
+	FileDecrypt(domainId int, srcPath string, dstPath string) error
+	EncryptWithKey(key string, data string) (string, error)
+	DecryptWithKey(key string, data string) (string, error)
+}
+
+type InitFunc func() (Engine, error)
+
+var (
+	engines map[string]InitFunc
+)
+
+func init() {
+	engines = make(map[string]InitFunc)
+}
+
+func Register(algo string, initFunc InitFunc) error {
+	if _, exists := engines[algo]; exists {
+		return fmt.Errorf("engine already registered %s", algo)
+	}
+
+	engines[algo] = initFunc
+
+	return nil
+}
+
+func New(algo string) (engine Engine, err error) {
+	if initFunc, exists := engines[algo]; exists {
+		return initFunc()
+	}
+
+	return nil, fmt.Errorf("no such algorithm %s", algo)
+}
diff --git a/vendor/pkg/gopkgs/cbb_adapt/src/go/pbkdf2/pbkdf2.go b/vendor/pkg/gopkgs/cbb_adapt/src/go/pbkdf2/pbkdf2.go
new file mode 100644
index 0000000..4580495
--- /dev/null
+++ b/vendor/pkg/gopkgs/cbb_adapt/src/go/pbkdf2/pbkdf2.go
@@ -0,0 +1,57 @@
+// Copyright (c) Huawei Technologies Co., Ltd. 2019. All rights reserved.
+// iSulad-kit licensed under the Mulan PSL v1.
+// You can use this software according to the terms and conditions of the Mulan PSL v1.
+// You may obtain a copy of Mulan PSL v1 at:
+//     http://license.coscl.org.cn/MulanPSL
+// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+// PURPOSE.
+// See the Mulan PSL v1 for more details.
+// Description: iSulad image kit
+// Author: lifeng
+// Create: 2019-05-06
+
+package pbkdf2
+
+import (
+	"crypto/hmac"
+	"hash"
+)
+
+func Key(password, salt []byte, iter, keyLen int, h func() hash.Hash) []byte {
+	var buffer [4]byte
+
+	engine := hmac.New(h, password)
+	hashLen := engine.Size()
+	if hashLen < 0 {
+		return nil
+	}
+	numBlocks := (keyLen + hashLen - 1) / hashLen
+
+	numAll := make([]byte, 0, numBlocks*hashLen)
+	U := make([]byte, hashLen)
+
+	for block := 1; block <= numBlocks; block++ {
+		engine.Reset()
+		engine.Write(salt)
+		buffer[0] = byte(block >> 24)
+		buffer[1] = byte(block >> 16)
+		buffer[2] = byte(block >> 8)
+		buffer[3] = byte(block)
+		engine.Write(buffer[:4])
+		numAll = engine.Sum(numAll)
+		T := numAll[len(numAll)-hashLen:]
+		copy(U, T)
+
+		for n := 2; n <= iter; n++ {
+			engine.Reset()
+			engine.Write(U)
+			U = U[:0]
+			U = engine.Sum(U)
+			for x := range U {
+				T[x] ^= U[x]
+			}
+		}
+	}
+	return numAll[:keyLen]
+}
-- 
2.19.1

