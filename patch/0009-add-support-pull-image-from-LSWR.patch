From cc672999c8a55616979cd31d1e8f9264be6212d4 Mon Sep 17 00:00:00 2001
From: LiFeng <lifeng68@huawei.com>
Date: Mon, 15 Apr 2019 06:43:06 -0400
Subject: [PATCH 09/31] add support pull image from LSWR

Signed-off-by: LiFeng <lifeng68@huawei.com>
---
 .../containers/image/docker/docker_client.go       | 13 +++-
 .../containers/image/oci/layout/oci_src.go         |  2 +-
 .../image/pkg/tlsclientconfig/tlsclientconfig.go   | 75 +++++++++++++++++++++-
 vendor/github.com/containers/image/types/types.go  |  3 +
 4 files changed, 88 insertions(+), 5 deletions(-)

diff --git a/vendor/github.com/containers/image/docker/docker_client.go b/vendor/github.com/containers/image/docker/docker_client.go
index 23d2ac7..6725707 100644
--- a/vendor/github.com/containers/image/docker/docker_client.go
+++ b/vendor/github.com/containers/image/docker/docker_client.go
@@ -53,7 +53,7 @@ var (
 	ErrV1NotSupported = errors.New("can't talk to a V1 docker registry")
 	// ErrUnauthorizedForCredentials is returned when the status code returned is 401
 	ErrUnauthorizedForCredentials = errors.New("unable to retrieve auth token: invalid username/password")
-	systemPerHostCertDirPaths     = [2]string{"/etc/containers/certs.d", "/etc/docker/certs.d"}
+	systemPerHostCertDirPaths     = [3]string{"/etc/isulad/certs.d", "/etc/containers/certs.d", "/etc/docker/certs.d"}
 )
 
 // extensionSignature and extensionSignatureList come from github.com/openshift/origin/pkg/dockerregistry/server/signaturedispatcher.go:
@@ -242,7 +242,16 @@ func newDockerClient(sys *types.SystemContext, registry, reference string) (*doc
 	if err != nil {
 		return nil, err
 	}
-	if err := tlsclientconfig.SetupCertificates(certDir, tr.TLSClientConfig); err != nil {
+
+	// Check if Decrypted key shall be used (default=true) which
+	// be specified in the SystemContext UseDecryptedKey.
+	IsDecrypted := true
+	if sys != nil && sys.UseDecryptedKey != types.OptionalBoolUndefined {
+		// Only use the SystemContext if the actual value is defined.
+		IsDecrypted = sys.UseDecryptedKey == types.OptionalBoolTrue
+	}
+
+	if err := tlsclientconfig.SetupCertificates(certDir, tr.TLSClientConfig, IsDecrypted); err != nil {
 		return nil, err
 	}
 
diff --git a/vendor/github.com/containers/image/oci/layout/oci_src.go b/vendor/github.com/containers/image/oci/layout/oci_src.go
index cc536f6..2b544c9 100644
--- a/vendor/github.com/containers/image/oci/layout/oci_src.go
+++ b/vendor/github.com/containers/image/oci/layout/oci_src.go
@@ -29,7 +29,7 @@ func newImageSource(sys *types.SystemContext, ref ociReference) (types.ImageSour
 	tr.TLSClientConfig = tlsconfig.ServerDefault()
 
 	if sys != nil && sys.OCICertPath != "" {
-		if err := tlsclientconfig.SetupCertificates(sys.OCICertPath, tr.TLSClientConfig); err != nil {
+		if err := tlsclientconfig.SetupCertificates(sys.OCICertPath, tr.TLSClientConfig, true); err != nil {
 			return nil, err
 		}
 		tr.TLSClientConfig.InsecureSkipVerify = sys.OCIInsecureSkipTLSVerify
diff --git a/vendor/github.com/containers/image/pkg/tlsclientconfig/tlsclientconfig.go b/vendor/github.com/containers/image/pkg/tlsclientconfig/tlsclientconfig.go
index 6785564..b564e23 100644
--- a/vendor/github.com/containers/image/pkg/tlsclientconfig/tlsclientconfig.go
+++ b/vendor/github.com/containers/image/pkg/tlsclientconfig/tlsclientconfig.go
@@ -9,15 +9,75 @@ import (
 	"path/filepath"
 	"strings"
 	"time"
+	"fmt"
+	"crypto/rand"
+
 
 	"github.com/docker/go-connections/sockets"
 	"github.com/docker/go-connections/tlsconfig"
 	"github.com/pkg/errors"
 	"github.com/sirupsen/logrus"
+
+	_ "pkg/gopkgs/cbb_adapt/src/go/aeswithkey"
+	"pkg/gopkgs/cbb_adapt/src/go/gcrypto"
 )
 
+var (
+	// ErrAlreadyExists is an error returned if an image being pushed
+	// already exists on the remote side
+	ErrAlreadyExists = errors.New("Image already exists")
+	psmPath          = "/etc/isulad/psm"
+	IsDecrypted      = false
+)
+
+func decodeKeyFile(key, originKey string, directory string) error {
+	//directory is like to /etc/docker/certs.d/ip:port
+	fields := strings.Split(directory, "/")
+	rootKeyFolder := fields[len(fields)-1]
+	if len(rootKeyFolder) <= 1 {
+		return fmt.Errorf("get rootKeyFolder err")
+	}
+	if env := os.Getenv("PAAS_CRYPTO_PATH"); env == "" {
+		if err := os.Setenv("PAAS_CRYPTO_PATH", filepath.Join(psmPath, rootKeyFolder)); err != nil {
+			return err
+		}
+	}
+
+	psmCrypto, err := gcrypto.New("aeswithkey")
+	if err != nil {
+		return err
+	}
+
+	data, err := ioutil.ReadFile(key)
+	if err != nil {
+		return err
+	}
+
+	decdata, err := psmCrypto.Decrypt(0, string(data))
+	if err != nil {
+		return err
+	}
+
+	if err := ioutil.WriteFile(originKey, []byte(decdata), 0600); err != nil {
+		return err
+	}
+	return nil
+}
+
+func randStr(strSize int) string {
+	dictionary := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+
+	var bytes = make([]byte, strSize)
+	rand.Read(bytes)
+
+	for k, v := range bytes {
+		bytes[k] = dictionary[v%byte(len(dictionary))]
+	}
+	return string(bytes)
+}
+
 // SetupCertificates opens all .crt, .cert, and .key files in dir and appends / loads certs and key pairs as appropriate to tlsc
-func SetupCertificates(dir string, tlsc *tls.Config) error {
+func SetupCertificates(dir string, tlsc *tls.Config, IsDecrypted bool) error {
 	logrus.Debugf("Looking for TLS certificates and private keys in %s", dir)
 	fs, err := ioutil.ReadDir(dir)
 	if err != nil {
@@ -63,7 +123,18 @@ func SetupCertificates(dir string, tlsc *tls.Config) error {
 			if !hasFile(fs, keyName) {
 				return errors.Errorf("missing key %s for client certificate %s. Note that CA certificates should use the extension .crt", keyName, certName)
 			}
-			cert, err := tls.LoadX509KeyPair(filepath.Join(dir, certName), filepath.Join(dir, keyName))
+			keyPath := filepath.Join(dir, keyName)
+			keyOriginPath := keyPath
+
+			if !IsDecrypted {
+				keyOriginPath = filepath.Join(dir, "origin"+randStr(10)+keyName)
+				defer os.Remove(keyOriginPath)
+				if err := decodeKeyFile(keyPath, keyOriginPath, dir); err != nil {
+					return err
+				}
+			}
+
+			cert, err := tls.LoadX509KeyPair(filepath.Join(dir, certName), keyOriginPath)
 			if err != nil {
 				return err
 			}
diff --git a/vendor/github.com/containers/image/types/types.go b/vendor/github.com/containers/image/types/types.go
index 9fdab23..814218d 100644
--- a/vendor/github.com/containers/image/types/types.go
+++ b/vendor/github.com/containers/image/types/types.go
@@ -509,6 +509,9 @@ type SystemContext struct {
 	// === dir.Transport overrides ===
 	// DirForceCompress compresses the image layers if set to true
 	DirForceCompress bool
+
+	// Use decrypted private key by default (defaults to true)
+	UseDecryptedKey OptionalBool
 }
 
 // ProgressProperties is used to pass information from the copy code to a monitor which
-- 
1.8.3.1

